# 一、现代 C/C++ 语言与基础

**1. 什么是 RAII？有何优势？**  

RAII（Resource Acquisition Is Initialization）是一种 C++ 对象管理资源的核心原则——“资源获取即初始化”。其思想是：当对象构造时立即获得外部资源（如内存、文件句柄、网络连接），当对象析构时自动释放这些资源。RAII 将资源的生命周期与对象的作用域绑定，防止忘记释放资源或因异常导致资源泄漏。

**2. `unique_ptr`、`shared_ptr` 与 `weak_ptr` 各自特点是什么？**

- `unique_ptr` 是一种独占所有权的智能指针，禁止复制，只能移动。它内部只保存一个裸指针，性能开销很小。当 `unique_ptr` 被销毁或其持有的指针被重新赋值时，会立即删除所管理的对象。
- `shared_ptr` 通过引用计数实现共享所有权，允许多个指针共同管理同一对象。每个 `shared_ptr` 内部包含一个控制块，存储引用计数和删除器；当最后一个 `shared_ptr` 被销毁时，才释放对象。
- `weak_ptr` 则持有对象的非拥有引用，不增加引用计数，用于打破循环引用或临时访问。

`unique_ptr` 更轻量，适合独占资源，如容器元素；`shared_ptr` 适合复杂共享关系，但引用计数的线程安全实现增加了开销。

**3. 移动语义与完美转发解决了什么问题？**

移动语义允许通过转移资源所有权而非复制来提高效率，类似把旧电脑硬盘直接装到新电脑里，不再复制文件。完美转发利用 `std::forward` 保持参数的左值/右值属性，以便模板函数不改变实参特性。

**4. `constexpr` 和 `const` 有什么区别？**

`const` 修饰不可修改的值；`constexpr` 则要求在编译期求值，可用于常量表达式、模板参数等。`constexpr` 变量可以放在编译阶段计算。

**5. C++20 中的 Concepts 解决了什么问题？**

Concepts 为模板参数提供显式约束，使得编译器在实例化时能够给出更清晰的错误信息。可以理解为为模板函数设定“入门条件”，不满足条件的类型禁止实例化。

**6. 模板元编程有何用处？**

模板元编程在编译期进行类型运算或逻辑运算，例如根据模板递归计算斐波那契数值。

**7. 什么是 Rule of Zero/Three/Five？**

- Rule of Zero：若类只使用 RAII 成员对象管理资源，则不需自定义析构、拷贝和移动函数。
    
- Rule of Three：若定义了析构函数，应同时自定义拷贝构造和拷贝赋值运算符。
    
- Rule of Five：在 Rule of Three 的基础上增加移动构造和移动赋值函数。
    

**8. 虚函数和纯虚函数区别？**

虚函数拥有默认实现，可被覆写；纯虚函数没有实现，类中含有纯虚函数时为抽象类，不能直接实例化。

**9. C++ 与 Rust 在资源管理上的不同？**

C++ 借助 RAII 和智能指针，需要程序员明确控制资源所有权。Rust 则通过语言层面的所有权系统和借用规则，在编译期保证资源安全地移动或共享。

**10. `map` 与 `unordered_map` 的差异是什么？**

`map` 底层是平衡二叉树，按键排序，查找复杂度 O(log n)；`unordered_map` 使用哈希表，平均 O(1) 查找，但不保证顺序。二者选择取决于是否需要保持顺序或自定义比较。

# 二、操作系统

### 2.1 进程与线程

**1. 进程和程序的区别？**

- **程序**：是静态的，指令和数据的集合，只是存放在磁盘上的一份文件。
- **进程**：是程序的一次执行实例，是动态的，包含程序计数器、寄存器和变量的当前值。

**2. 进程的基本状态及状态转换图？**

进程常见 5 种状态：
- **新建**（New）
- **就绪**（Ready）
- **运行**（Running）
- **阻塞**（Blocked/Waiting）
- **终止**（Terminated）

转换关系：
- 新建 → 就绪（完成创建）
- 就绪 ↔ 运行（获得/失去 CPU）
- 运行 → 阻塞（等待 I/O 等资源）
- 阻塞 → 就绪（等待事件完成）
- 运行/阻塞 → 终止（执行结束或被终止）

**3. 进程控制块（PCB）包含哪些信息？**

包括：
- 进程标识符（PID）
- 处理机状态（寄存器、程序计数器、PSW 等）
- 进程调度信息（优先级、调度状态、队列指针等）
- 内存管理信息（页表、段表）
- 文件管理信息（打开文件表等）

**4. 线程和进程的区别？优缺点？**    

- **粒度**：进程是资源分配的最小单位；线程是 CPU 调度的最小单位。
- **内存**：进程独立内存空间，线程共享进程内存（代码段、数据段），但有独立栈和寄存器。
- **开销**：进程创建/切换开销大，线程更轻量。
- **通信**：进程间通信（IPC）复杂，线程共享内存通信简单。
- **优缺点总结**：
    - 进程：稳定、安全，但切换代价高。
    - 线程：高效、共享方便，但可能影响稳定性（一个线程挂掉导致整个进程崩溃）。

**5. 线程的上下文切换和进程上下文切换区别？**

- **进程切换**：保存和恢复 PCB，切换虚拟地址空间、页表、内核栈和硬件上下文 → 开销大。
- **线程切换**：只切换寄存器、栈指针和 TCB，不需要切换地址空间 → 开销小。

**6. 什么是协程？与线程的区别？**

- **协程**：用户态的轻量级线程，可以在函数内部挂起/恢复，不涉及内核调度。
- **区别**：
    - 协程切换无需陷入内核，开销比线程小。
    - 协程属于单线程，不需要加锁即可共享数据。
    - 一个线程可包含多个协程。

**7. Linux 中创建线程的方法有哪些？**

- `pthread_create()`（POSIX 线程库，最常用）
- C++11 标准库 `std::thread`（封装了 pthread）
- 低层接口如 `clone()` 系统调用（Linux 内核使用）  
    （宝典中强调了 `fork()` 用于进程创建，但线程创建主要依赖 pthread。）

**8. 孤儿进程、僵尸进程的原理和处理方法？**

- **孤儿进程**：父进程退出，但子进程仍在运行；会被 `init` 进程收养并负责回收。
- **僵尸进程**：子进程结束，但父进程未调用 `wait()` 回收，子进程 PCB 残留。
- **处理方法**：
    - 父进程主动 `wait()/waitpid()` 回收。
    - 设置 `SIGCHLD` 信号处理函数，自动回收。

**9. 守护进程的特点和实现？**

- **特点**：
    - 长期后台运行，无终端控制。
    - 生命周期长，常用于服务。
- **实现步骤**：
    1. `fork()` 创建子进程，父进程退出。
    2. 子进程 `setsid()` 创建新会话，脱离控制终端。
    3. 修改工作目录（通常 `/`），重设文件权限掩码。
    4. 关闭/重定向标准输入输出。

**10. 多线程编程中的共享数据如何保证安全？**

常用同步手段：
- **互斥锁 (mutex)**：保证同一时间只有一个线程访问临界区。
- **读写锁 (rwlock)**：允许多个读者同时访问，但写者独占。
- **信号量 (semaphore)**：用于控制资源数量。
- **条件变量**：线程间事件同步。    
- **原子操作**：如 C++11 `std::atomic`。

### 2.2 进程调度与并发

**1. 抢占式和非抢占式调度的区别？**

- **非抢占式**：进程一旦获得 CPU，就会一直运行到结束或阻塞才会释放处理机。实现简单，但可能导致长作业独占 CPU 。
- **抢占式**：系统允许强行中断正在运行的进程，把 CPU 分配给更高优先级或更紧急的进程，响应及时，但开销更大。

**2. 常见的调度算法（FCFS、SJF、优先级、RR、多级反馈队列等）？**

- **先来先服务 (FCFS)**：按到达顺序调度，公平但对短作业不友好。
- **短作业优先 (SJF)**：优先调度运行时间短的作业，平均等待时间最小，但需要预估运行时间。
- **优先级调度**：优先级高的作业先执行，可能导致饥饿。
- **时间片轮转 (RR)**：每个进程分配固定时间片，公平适合分时系统。
- **多级反馈队列 (MLFQ)**：结合多种策略，动态调整优先级，常用于通用操作系统。

**3.  实时调度算法有哪些？**

常见实时调度包括：
- **Rate Monotonic (RM)**：周期短的任务优先。
- **Earliest Deadline First (EDF)**：截止时间最早的任务优先。
- **Least Laxity First (LLF)**：宽限时间最小的任务优先。

**4. Linux 的调度策略 CFS、RT、Deadline 有何区别？**

- **CFS (Completely Fair Scheduler)**：Linux 默认调度器，基于时间片的公平调度，适合普通任务。
- **RT (Real-Time)**：实时调度策略，包括 FIFO 和 RR，适合需要严格响应时间的任务。
- **Deadline**：基于任务的截止时间，结合 EDF 与 RT 特性，常用于实时系统。

**5. 进程同步方式有哪些？（信号量、互斥锁、条件变量、自旋锁、读写锁等）**

- **信号量 (semaphore)**：计数器机制，用于互斥或控制资源数量 。
- **互斥锁 (mutex)**：保证同一时刻只有一个线程/进程访问临界区：基于事件的线程同步 。
- **自旋锁 (spinlock)**：忙等方式，适合短时间锁竞争 。
- **读写锁 (rwlock)**：支持多读单写，效率高【7†C 面试宝典完整版.pdf†L8-L13】。
- **共享内存**
- **管道 (pipe)**
- **消息队列 (message queue)**
- **Socket**

**6. 线程通信的方式？（共享内存、管道、消息队列、socket 等）**

线程通信方式常用的有共享内存、消息队列、条件变量、信号量等，其中共享内存最快，但需要同步机制保证安全；消息队列和条件变量常用于生产者-消费者模型；而管道和 socket 更适合跨进程或跨机器的通信。

**7. 什么是临界区，如何避免冲突？**

- **临界区**：访问共享资源的一段代码。
- **避免冲突的方法**：加锁机制（互斥锁、信号量、读写锁）、原子操作等 。

**8. 什么是死锁？死锁产生的四个必要条件？**

**死锁**：多个进程因资源竞争而互相等待，无法推进。
- **必要条件** ：
    1. **互斥条件**：资源不能同时被多个进程使用。
    2. **请求保持条件**：已占有资源的进程提出新请求而不释放已有资源。
    3. **不可剥夺条件**：进程已获得的资源不可强制剥夺。
    4. **循环等待条件**：进程间形成环路等待。


**9. 死锁的预防、避免、检测与解除方法？**

- **预防**：破坏四个必要条件之一（如资源一次性分配，允许剥夺，规定资源顺序） 。
- **避免**：采用银行家算法。
- **检测**：通过资源分配图、等待图检测环路。
- **解除**：撤销或挂起部分进程，释放资源后重启。

**10. 银行家算法的基本原理？**

- 是一种**避免死锁的算法**，由 Dijkstra 提出。
- 核心思想：系统在分配资源时，先预判此次分配是否会使系统进入「不安全状态」。
- 如果会进入不安全状态，则拒绝分配，等待以后再分配；否则允许。  

# 三、网络基础

**1. OSI 七层模型的主要职责是什么？**

从低到高：物理层负责比特传输，数据链路层封装帧并纠错，网络层负责路由与寻址，传输层提供端到端服务，会话层管理会话状态，表示层处理数据编码压缩，应用层面向用户协议。

**2. TCP 和 UDP 有何区别？**

TCP 面向连接，可靠传输且顺序保证，适合文件传输；UDP 无连接，开销小但不保证可靠或顺序，适用于实时音视频。

**3. 为什么 TCP 需要三次握手建立连接？**

第一次握手客户端发送 SYN 请求，第二次服务器回复 SYN+ACK 表示收到并同步序列号，第三次客户端回 ACK 确认，确保双方都准备好传输。

**4. 为何断开连接要四次挥手？**

因为 TCP 双向通信需要双方独立关闭。先由主动断开方发送 FIN 请求半关闭，接收方 ACK 后再发送 FIN，最后对方 ACK。

**5. HTTP 的 GET 和 POST 区别？**

GET 用于获取资源，参数附在 URL 中，幂等且可缓存；POST 用于提交数据，参数在请求体中，非幂等，一般不会缓存。

**6. DNS 的作用是什么？**

将易记的域名解析为 IP 地址，可类比电话簿把人名对应到电话号码。

**7. SSL/TLS 如何保障 HTTPS 安全？**

TLS 使用公钥加密和对称加密结合，确保传输的机密性、完整性和认证性，从而防止窃听和篡改。

**8. 什么是 NAT？**

网络地址转换允许多个私有 IP 共享一个公网 IP，节省 IPv4 地址并增强内网安全，相当于公寓门卫转发邮件。

**9. TCP 滑动窗口机制有什么作用？**

滑动窗口决定一方可以未确认地发送多少数据，实现流量控制，防止发送方过快淹没接收方。

**10. 长连接与短连接的区别？**

长连接在多个请求间复用同一 TCP 连接，减少握手开销；短连接每次请求完成即断开，适合轻量任务。

# 四、并发与网络编程

**1. `select`、`poll` 与 `epoll` 有何区别？**

`select` 受 FD 数量限制，采用位图轮询；`poll` 用链表替代位图但仍遍历所有 FD；`epoll` 使用事件通知机制，只在事件发生时唤醒，因此在大量连接下效率更高。

**2. 线程池的优势是什么？**

线程池复用一组固定线程处理任务，避免频繁创建/销毁线程的开销，提高吞吐量。

**3. 什么是阻塞 I/O 和非阻塞 I/O？**

阻塞 I/O 调用会等待数据准备好；非阻塞 I/O 立即返回，如果未准备好会返回错误。非阻塞结合事件机制可有效提升并发。

**4. 异步 I/O 和同步 I/O 差别？**

异步 I/O 由操作系统完成数据读写，完成后通知应用；同步 I/O 则需要应用等待操作结束。

**5. 互斥锁和信号量有何区别？**

互斥锁保护临界区，一次只有一个线程进入；信号量可控制多个资源的访问数目，如停车场车位计数。

**6. 什么是死锁？如何避免？**

死锁是多个线程互相等待无法推进的状态。避免策略包括按固定顺序加锁、使用尝试加锁超时、破坏持有并等待等。

**7. CAS 操作是什么？**

CAS（Compare-And-Swap）是一种无锁原子操作，它比较内存中值是否为期望值，若匹配则更新，否则重试。

**8. 什么是假共享？**

不同线程操作位于同一缓存行的变量导致频繁更新缓存，提高延迟。通过填充对齐或分离数据结构可避免。

**9. 协程与线程有什么不同？**

协程在用户态调度，切换开销小但不能利用多核并行；线程由内核调度，可真正并行执行。协程更适合 I/O 密集型任务。

**10. Reactor 与 Proactor 模式区别？**

Reactor 将事件分发给各处理器；Proactor 让内核完成操作并通知应用处理结果。

# 五、数据结构与算法

以下算法题均可在 LeetCode 上找到对应实现与讨论

### 1. 数组操作类

- **前缀和**：`303. 区域和检索 - 数组不可变`、`560. 和为 K 的子数组`、`238. 除自身以外数组的乘积`、`724. 寻找数组的中心下标`、`53. 最大子序和`。
    
- **差分数组**：`1109. 航班预订统计`、`1094. 拼车`、`370. 区间加法`、`798. 得分最高的最小轮调`。
    
- **二维数组与矩阵**：`304. 二维区域和检索 - 矩阵不可变`、`59. 螺旋矩阵 II`、`542. 01 矩阵`、`130. 被围绕的区域`、`73. 矩阵置零`。
    

### 2. 双指针技巧

- **数组双指针**：`26. 删除有序数组中的重复项`、`27. 移除元素`、`80. 删除有序数组中的重复项 II`、`283. 移动零`、`167. 两数之和 II - 输入有序数组`。
    
- **滑动窗口**：`3. 无重复字符的最长子串`、`76. 最小覆盖子串`、`209. 长度最小的子数组`、`30. 串联所有单词的子串`、`239. 滑动窗口最大值`。
    
- **二分查找**：`704. 二分查找`、`35. 搜索插入位置`、`33. 搜索旋转排序数组`、`34. 在排序数组中查找元素的第一个和最后一个位置`、`74. 搜索二维矩阵`。
    
- **随机化算法**：`384. 打乱数组`、`398. 随机数索引`、`382. 链表随机节点`。
    

### 3. 贪心与其他算法

- **贪心策略**：`455. 分发饼干`、`122. 买卖股票的最佳时机 II`、`55. 跳跃游戏`、`45. 跳跃游戏 II`、`435. 无重叠区间`、`763. 划分字母区间`。
    
- **数学**：`50. Pow(x, n)`、`136. 只出现一次的数字`、`172. 阶乘后的零`、`204. 计数质数`、`202. 快乐数`。
    
- **随机算法**：`382. 链表随机节点`、`398. 随机数索引`。
    

### 4. 栈与队列、哈希与设计

- **栈与队列**：`20. 有效的括号`、`155. 最小栈`、`150. 逆波兰表达式求值`、`232. 用栈实现队列`、`225. 用队列实现栈`、`239. 滑动窗口最大值`、`735. 行星碰撞`。
    
- **哈希与设计**：`1. 两数之和`、`128. 最长连续序列`、`49. 字母异位词分组`、`380. 常数时间插入、删除和获取随机元素`、`146. LRU 缓存机制`、`460. LFU 缓存`、`706. 设计哈希映射`。
    

### 5. 链表与双指针、递归

- **链表基础与双指针**：`206. 反转链表`、`141. 环形链表`、`160. 相交链表`、`234. 回文链表`、`19. 删除链表的倒数第 N 个结点`。
    
- **递归与回溯**：`46. 全排列`、`47. 全排列 II`、`78. 子集`、`90. 子集 II`、`77. 组合`、`39. 组合总和`、`40. 组合总和 II`、`216. 组合总和 III`、`93. 复原 IP 地址`、`17. 电话号码的字母组合`、`51. N 皇后`。
    

### 6. 树与高级数据结构

- **二叉树遍历与基础**：`94. 二叉树的中序遍历`、`144. 前序遍历`、`145. 后序遍历`、`102. 二叉树的层序遍历`、`107. 层序遍历 II`、`112. 路径总和`、`226. 翻转二叉树`。
    
- **二叉搜索树（BST）**：`98. 验证二叉搜索树`、`700. 二叉搜索树中的搜索`、`530. 二叉搜索树的最小绝对差`、`501. 二叉搜索树中的众数`、`235. 二叉搜索树的最近公共祖先`。
    
- **堆**：`215. 数组中的第 K 个最大元素`、`347. 前 K 个高频元素`、`295. 数据流中的中位数`、`378. 有序矩阵中第 k 小的元素`、`703. 数据流中的第 K 大元素`。
    
- **Trie（前缀树）**：`208. 实现 Trie`、`211. 添加与搜索单词 - 数据结构设计`、`212. 单词搜索 II`、`642. 设计自动补全系统`、`720. 词典中最长的单词`。
    

### 7. 图论与搜索

- **深度优先/广度优先搜索**：`200. 岛屿数量`、`695. 岛屿的最大面积`、`130. 被围绕的区域`、`417. 太平洋大西洋水流问题`、`733. 图像渲染`。
    
- **最短路径与 BFS 题型**：`542. 01 矩阵`、`1091. 二进制矩阵中的最短路径`、`752. 打开转盘锁`、`127. 单词接龙`、`286. 墙与门`、`433. 最短基因变化`。
    
- **并查集**：`684. 冗余连接`、`547. 省份数量`、`323. 无向图中连通分量的数目`、`1202. 交换字符串中的元素`、`959. 由斜杠划分区域`。
    

### 8. 动态规划与分治

- **动态规划**：`70. 爬楼梯`、`198. 打家劫舍`、`213. 打家劫舍 II`、`53. 最大子序和`、`416. 分割等和子集`、`221. 最大正方形`、`647. 回文子串`、`72. 编辑距离`、`718. 最长重复子数组`、`518. 零钱兑换 II`。
    
- **分治算法**：`241. 为运算表达式设计优先级`、`23. 合并 K 个升序链表`、`215. 数组中的第 K 个最大元素`（快速选择）、`95. 不同的二叉搜索树 II`、`108. 将有序数组转换为二叉搜索树`。

# 六、系统设计与工程化

**1. 系统设计时应考虑哪些步骤？**

包括需求分析、规模估算、组件拆分、数据模型和 API 设计、选型（缓存/数据库/队列）、容灾和扩展性，最后进行性能优化和监控。

**2. 什么是 CAP 定理？**

在分布式系统中，一致性、可用性和分区容忍性三者不能兼得，只能取其二。例如很多 NoSQL 数据库牺牲一致性换取高可用和分区容忍。

**3. 如何设计一个 URL 短链服务？**

核心是生成短码映射原始 URL，可使用自增 ID+Base62 编码或哈希；需要存储映射关系、处理冲突和过期逻辑，并确保短链唯一。

**4. 限流算法有哪些？**

常见有令牌桶（根据令牌产生速率放行请求）和漏桶（按照固定速率输出），用于防止突发流量冲垮系统。

**5. 如何保证消息队列的消息不丢失？**

通过持久化消息、ACK 确认机制、重试和幂等性处理确保即使服务重启也不会丢失或重复消费消息。

**6. 如何实现高可用服务？**

使用主备、故障转移、心跳检测、负载均衡和多机房容灾，避免单点故障。做好监控告警和自动恢复。

**7. 设计一个系统监控平台需要哪些模块？**

数据采集（指标、日志）、存储和聚合、阈值告警、可视化展示。支持自定义指标和多维度分析。

**8. GitFlow 工作流有哪些优缺点？**

优点是分支结构清晰，适合多人协作；缺点是分支多，合并流程复杂。短周期项目可考虑 trunk-based development。

**9. 设计一个分布式 ID 生成器的思路？**

常见方案有 Snowflake（时间戳+机器ID+序列号）或数据库自增；需保证唯一性、递增性和高可用。

**10. 如何做配置中心？**

集中存储配置，客户端定期拉取或通过长连接推送；支持灰度发布、版本控制、权限管理和变更审计。

# 七、图形/游戏与音视频 （简）

**1. 光栅化渲染管线的关键阶段有哪些？**

主要包括顶点处理、图元装配、光栅化、片元着色及输出合并。每一步将三维模型转换为最终可显示的像素。

**2. 四元数为何优于欧拉角？**

欧拉角易产生万向节锁；四元数用四个数表示旋转，支持平滑插值和组合，避免死锁问题，适合动画和姿态控制。

**3. 骨骼动画如何实现？**

通过蒙皮技术，每个顶点绑定若干骨骼并设置权重，最终顶点位置是各骨骼变换的加权和。

**4. 为什么要使用四叉树进行碰撞检测？**

将空间递归划分为四个子区，减少不相关物体的检测次数，提高效率。

**5. Coyote Time 与 Jump Buffer 提升了什么？**

允许玩家在离开平台后的短暂时间内仍能跳跃或提前缓冲按键，使操作更宽容并提高游戏体验。

**6. RTMP 与 HLS 有何区别？**

RTMP 基于 TCP，低延迟，适合直播；HLS 基于 HTTP 将视频切片，稳定性高适合点播。

**7. 什么是 PBR？**

物理基渲染根据真实世界的物理属性（如金属度、粗糙度）计算光照，使画面更真实。

**8. 逆向运动学 (IK) 在动画中的作用？**

根据目标末端位置自动计算中间关节角度，实现角色肢体自然移动。

**9. 滑动窗口平均与 EMA 有何不同？**

滑动窗口平均使用固定窗口求平均，延迟固定；EMA 给新数据更大权重，响应快速但可能有滞后。

**10. 卡尔曼滤波的基本思想？**

结合系统模型预测和测量观测，迭代校正估计值，适用于有噪声的动态系统，例如姿态平滑。